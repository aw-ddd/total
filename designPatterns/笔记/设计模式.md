### 一、软件设计模式概述

#### 1. 使用设计模式的意义

设计模式本质上是面向对象设计原则的实际运用，是对于类的封装性，继承性，多态性以及类的关联关系和组合关系的充分理解。

#### 2. 设计模式的划分

##### 1. 根据目的划分

根据模式是用来完成什么工作来划分，这种方式可分为创建型、结构型和行为型模式三种。

1. 创建型模式：用于描述“怎样创建对象”，他的主要特点是“将对象的创建与使用分离”。比如单例、原型、工厂方法、抽象工厂、建造者等5中创建型模式。
2. 结构型模式：用于描述如何将类或对象按照某种布局组成更大的结构。比如代理、适配器、桥接、装饰、外观、享元、组合等7中结构型模式。
3. 行为型模式：用于描述类和对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。比如模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等11中行为型模式

##### 2. 根据作用范围来划分

根据模式是主要用于类还是主要用于对象上来分，这种方式可以分为类模式和对象模式两种

1. 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了，比如工厂方法、（类）适配器、模板方法、解释器属于该模式。
2. 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具有动态性。除了类模式之外的全部属于对象模式。

### 二、设计模式

#### 1. 单例模式

- **定义：**指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源浪费，或出现各个窗口显示的内容不一致的错误。
- **优点：**
  - 单例模式可以保证内存里只有一个实例，减少了内存的开销
  - 可以避免对于资源的多重占用
  - 单例模式设置全局访问点，可以优化和共享资源的访问。
- **缺点：**
  - 单例模式一般没有接口，扩展较为困难，如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则
  - 在并发测试中，单例模式不利于代码调试。在调试的过程中，如果单例中的代码如果没有执行完，也不能模拟生成一个新的对象。
  - 单例模式的功能代码通常是写在一个类中，如果功能设计的不合理，很容易违背单一职责原则。
- **应用场景：**
  - 需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少GC
  - 某些只要求生成一个对象的时候，如一个班中的班长，每个人的身份证号等
  - 某些类创建实例时占用资源较多，或者实例化时间较长，如多线程的线程池，网络连接池等
  - 频繁访问数据库或文件的对象
  - 对于一些控制硬件级别的操作或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套
  - 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象的访问速度。如Web中的配置对象，数据库的连接池等。

#### 2. 原型模式

- **定义：**用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象，在这里，原型实例指定了要创建的对象的种类。用这种方法创建对象十分高效，根本无需知道对象的创建细节。例如，Windows操作系统的安装通常比较耗时，但是如果是直接复制的话就很快了。
- **优点：**
  - Java自带的原型模式基于内存二进制流的复制，在性能上要比直接new一个对象要更加的优良。
  - 可以使用深克隆方式保存对象的状态，使用圆形模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程以便在需要的时候使用（例如恢复到某一历史状态），可辅助实现撤销操作。
- **缺点：**
  - 需要为每一个类都配置一个clone方法
  - clone方法位于类的内部，当对已有的类进行改造时，需要修改代码，违背了开闭原则。
  - 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层的对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆，浅克隆需要运用得当。

- **应用场景：**
  - 对象之间相同或者相似，即只是个别的几个属性不同的时候。
  - 创建对象的成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。
  - 创建一个对对象需要使用繁琐的数据准备或者访问权限，需要提高性能或者安全性
  - 系统中大量使用该类对象，且各个调用者都需要给他的属性重新复制。

#### 3. 简单工厂模式

- **定义：**定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类中。这满足创建型模式中所要求的的“创建于使用相分离”的特点。
- **优点：**
  - 工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例，客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。
  - 客户端无需知道所创建具体产品的类名，只需要知道参数即可。
  - 也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。
- **缺点：**
  - 简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受到影响。且工厂类代码会非常臃肿，违背高聚合原则。
  - 使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度。
  - 系统扩展困难，一旦增加新的产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂。
  - 简单工厂模式使用了static工厂方法，造成工厂角色无法形成基于继承的等级结构。
- **应用场景：**
  - 对于产品种类较少的情况下可以考虑使用简单工厂模式，使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑。可以很方便的创建爱你所需要的产品

#### 4. 工厂方法模式

- **定义：**简单工厂模式违背了开闭原则，而“工厂方法模式”，则是对于简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来的代码的情况下，只需要添加接口的实现类就可以引入新的产品，满足了开闭原则。
- **优点：**
  - 用户只需要知道具体的工厂名称就可以得到所要的产品，无需知道产品的具体创建过程。
  - 灵活性增强，对于新产品的创建，只需要多写一个相应的工厂类。
  - 典型的解耦框架。高层模块只需要知道产品的抽象类，无需关心其他的实现，满足迪米特法则，依赖倒置原理和里氏替换原则
- **缺点：**
  - 类的个数容易增多，增加复杂度
  - 增加了系统的抽象性和理解的难度
  - 抽象产品只能生产一种产品，此弊端可以使用抽象工厂模式解决

- **应用场景：**
  - 客户只知道创建产品的工厂名，而不知道具体的产品名。
  - 创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。
  - 客户不关心创建产品的细节，只关心产品的品牌

#### 5. 抽象工厂模式

- **定义：**是一种为访问类提供一个创建一组相关或相互依赖对象的及入口，且访问类无需指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可以生成多个等级的产品。

- **优点：**
  - 可以在类的内部对产品组中相关联的多等级产品共同管理，而不必专门引入多个新的类来管理。
  - 当需要产品族时，抽象工厂可以保证客户端始终只是用同一个产品的产品组。
  - 抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改源代码，满足开闭原则

- **缺点：**
  - 当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改，增加了系统的抽象性和理解难度

#### 6. 建造者模式

- **定义：**将复杂的对象的构造与表示分离，相同的构造过程可以创建不同的表示，这样的设计模式被称为建造者模式。他将一个复杂的对象分解为多个简单的对象，之后一步一步构建。产品的组成部分是不变的，但是每一部分确实可以灵活选择的。
- **优点：**
  - 封装性好，构建与表示分离
  - 扩展性好，各个具体建造者相互独立，有利于系统的解耦
  - 使用者不需要了解内部的组成细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何的影响，便于控制细节风险
- **缺点：**
  - 产品的组成部分必须相同，这限制了其使用范围
  - 如果产品的内部变化复杂，当产品的内部发生变化那么建造者爷要同步进行修改，后期的维护成本较高

- **应用场景：**
  - 相同的方法，不同的执行顺序，产生不同的结果
  - 多个部件或零件，都可以装配到一个对象中，但是产生的结果又不相同
  - 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用
  - 初始化一个对象特别复杂，参数多，而且很多参数都具有默认值

#### 7. 代理模式

- **定义：**在某些情况下，需要给某个对象提供一个代理以控制该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介
- **优点：**
  - 代理对象在目标对象与使用者中间，可以保护目标对象
  - 代理模式可以扩展目标对象的功能
  - 代理模式可以将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性
- **缺点：**
  - 代理模式会造成系统设计中类的增加（增加了一个代理类）
  - 客户端与目标对象之间增加了一个代理对象，发送到目标对象的请求时间会延长
  - 增加了系统的复杂度

- **应用场景：**
  - 远程代理：这种场景下，通常是因为目标对象存在于不同的地址空间，通过远程代理，可以对客户端只暴露一个端口，方便客户端的访问
  - 虚拟代理：这种场景下，通常是因为由于要创建的目标对象开销很大时。比如下载一副图片时，因某种计算比较复杂而段时间无法完成，这时就通过一副小比例的虚拟代理来替换真实对象，消除用户对于服务器处理很慢的感觉
  - 安全代理：这种场景下，通常是为了控制不同种类客户对于真实访问对象的访问权限
  - 智能指引：主要用于调用目标对象时，代理附加一些额外的处理功能
  - 延迟加载：为了提高系统的性能，延迟对目标的加载

#### 8. 适配器模式

- **定义：**将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不嗯呢一起工作的类也可以一起工作。
- **优点：**
  - 客户端通过适配器可以透明地调用目标接口
  - 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类
  - 将目标类与适配者类解耦，解决了目标类和适配者类接口不一致的问题
  - 在很多业务场景中符合开闭原则
- **缺点：**
  - 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性
  - 增加代码阅读难度，降低代码的可读性，过多使用适配器会使系统代码变得凌乱
- **应用场景：**
  - 以前开发的系统存在满足新系统功能需求的类，但是其接口和新的系统的接口不一致的情况下
  - 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同

#### 9. 桥接模式

- **定义：**将抽象和现实分离，使得他们可以独立的变化。它是用组合关系代替了继承的关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。桥接模式遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开放。
- **结构：**
  - 抽象化角色：定义抽象类，并包含一个对实现话对象的引用
  - 扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法
  - 实现化角色：定义实现化角色的接口，供扩展抽象化角色调用
  - 具体实现化角色：给出实现化角色接口的具体实现
- **优点：**
  - 抽象与实现分离，扩展能力强
  - 符合开闭原则
  - 符合合成复用原则
  - 其实现对客户透明
- **缺点：**
  - 由于聚合关系建立在抽象层，所以要求开发者对抽象化进行设计与编程，能正确识别出系统中两个独立变化的维度，这增加了系统的理解和设计难度。	

- **应用场景：**
  - 当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时
  - 当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时
  - 当一个系统需要在构建的抽象化角色和具体角色之间增加更多的灵活性时

#### 10. 装饰者模式

- **定义：**指在不改变现有的对象结构的情况下，动态的为一个对象扩展功能（即增加其额外的功能）的模式，他属于对象结构型模式
- **结构：**
  - 抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象
  - 具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责
  - 抽象装饰角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能
  - 具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任
- **优点：**
  - 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的为一个对象扩展功能，即插即用
  - 通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同的效果
  - 装饰器模式完全遵守开闭原则
- **缺点：**
  - 装饰者模式会增加很多子类，过度使用会增加程序的复杂性

- **应用场景：**
  - 当需要给一个现有类添加附加职责，又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类时终极类或者采用继承方法会产生大量的子类
  - 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而此时采用装饰者模式就很好实现
  - 当对象的功能要求可以动态的添加，也可以再动态的撤销时

#### 11. 外观模式

- **定义：**外观角色又被称为门面角色，是一种通过为多个复杂的子系统提供一致的接口，而使得这些子系统会更加容易被访问的模式。该模式对外有一个统一的接口，外部应用程序不需要关心内部子系统的具体实现细节，这样会大大降低程序的复杂性，提高程序的可维护性
- **结构：**
  - 外观角色：为多个子系统对外提供一个共同的接口
  - 子系统角色：实现系统的部分功能，客户可以通过外观角色访问他
  - 客户角色：通过一个外观角色访问各个子系统的功能
- **优点：**
  - 降低了子系统与客户端之间的耦合度，使的子系统的变化不会影响调用他的客户类
  - 对客户屏蔽了子系统组件，降低了客户处理的对象数目，并使得子系统使用起来更加的容易。
  - 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响到其他的子系统，也不会影响外观对象
- **缺点：**
  - 不能很好的限制客户使用子系统类，很容易带来未知风险
  - 增加新的子系统可能需要修改外观内或者客户端的源代码，违背了“开闭原则”
- **应用场景：**
  - 对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系
  - 当一个复杂的系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问
  - 当客户端与多个子系统之间存在很大的联系时，引入外观模式可以将他们分离，从而提高子系统的独立性和可移植性

#### 12. 享元模式

- **定义：**运用共享技术来有效的支持大量细粒度的对象复用，它通过共享已经存在的对象来大幅度减少需要创建的对象数量，避免大量相似的类的开销，从而提高系统资源的利用率
- **结构：**
  - 抽象享元角色：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入
  - 具体享元角色：实现抽象享元角色中所规定的接口
  - 非享元角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中
  - 享元工厂角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检查系统中是否存在符合要求的享元对象，如果存在则提供给客户，如果不存在的话，则创建一个新的享元对象
- **优点：**
  - 相同对象只需要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力
- **缺点：**
  - 为了使对象可以共享，需要将一些不能共享的状态外部化，这将会增加程序的复杂性
  - 读取享元模式的外部状态会使得运行时间稍微变长
- **应用场景：**
  - 系统中存在大量相同或者相似的对象，这些对象耗费大量的内存资源
  - 大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每个组只需要保存一个内部状态
  - 由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式

#### 13. 组合模式

- **定义：**组合模式有时又被称为部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。
- **结构：**
  - 抽象构件角色：它的主要作用是为树叶构建和树枝构件声明公共接口，并实现他们的默认行为，在透明的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成
  - 树叶构件角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中声明的公共接口
  - 树枝构件角色：是组合中的分支节点对象，它有子节点。他实现了构件角色中声明的接口，他的主要作用是存储和管理子不见，通常包含Add()、Remove()、GetChild()等方法
- **优点：**
  - 组合模式使得客户端代码可以一致的处理单个对象和组合关系，无需关心自己处理的是单个对象，还是组合对象，这简化了客户端代码
  - 更容易在组合体中加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足开闭原则
- **缺点：**
  - 设计较为复杂，客户端需要花费更多的时间来理清类之间的层次关系
  - 不容易限制容器中的构件
  - 不容易用继承的方法来增加构件的新功能
- **应用场景**
  - 在需要表示一个对象整体与部分的层次结构的场合
  - 要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中所有对象的场合